package controllers;

import dtos.*;
import models.Property;
import models.User;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import services.AuthService;
import services.PropertyManager;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/properties")
@CrossOrigin(origins = "*")
public class PropertyController {

    private final PropertyManager propertyManager;
    private final AuthService authService;
    private final DtoMapper dtoMapper;
    private final services.FileUploadService fileUploadService;

    public PropertyController(PropertyManager propertyManager, AuthService authService, DtoMapper dtoMapper,
            services.FileUploadService fileUploadService) {
        this.propertyManager = propertyManager;
        this.authService = authService;
        this.dtoMapper = dtoMapper;
        this.fileUploadService = fileUploadService;
    }

    @GetMapping
    public ResponseEntity<List<PropertyDTO>> search(
            @RequestParam(required = false) String search,
            @RequestParam(required = false) Double minPrice,
            @RequestParam(required = false) Double maxPrice,
            @RequestParam(required = false) Integer rooms) {

        List<Property> properties = propertyManager.search(search, minPrice, maxPrice, rooms);
        List<PropertyDTO> dtos = properties.stream()
                .map(dtoMapper::toPropertyDTO)
                .collect(Collectors.toList());
        return ResponseEntity.ok(dtos);
    }

    // ALIASES
    @GetMapping("/guest")
    public ResponseEntity<List<PropertyDTO>> guestBrowse() {
        return search(null, null, null, null);
    }

    @GetMapping("/search")
    public ResponseEntity<List<PropertyDTO>> advancedSearch(
            @RequestParam(required = false) String search,
            @RequestParam(required = false) Double minPrice,
            @RequestParam(required = false) Double maxPrice,
            @RequestParam(required = false) Integer rooms) {
        return search(search, minPrice, maxPrice, rooms);
    }

    @GetMapping("/my")
    public ResponseEntity<List<PropertyDTO>> getMyProperties(@RequestHeader("X-User-Id") Long userId) {
        List<Property> properties = propertyManager.getMyProperties(userId);
        return ResponseEntity.ok(properties.stream().map(dtoMapper::toPropertyDTO).collect(Collectors.toList()));
    }

    @GetMapping("/{id}")
    public ResponseEntity<PropertyWithOwnerDTO> getDetails(
            @RequestHeader(value = "X-User-Id", required = false) Long userId,
            @PathVariable Long id) {

        Optional<Property> propertyOpt = propertyManager.getPropertyById(id);
        if (propertyOpt.isEmpty()) {
            return ResponseEntity.notFound().build();
        }

        Property property = propertyOpt.get();
        User owner = authService.getUserById(property.getOwnerId());

        boolean isPublic = property.isVerified() && !property.isArchived();

        // Public access (Guests or Buyers viewing others' properties)
        if (userId == null) {
            if (!isPublic)
                return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
            return ResponseEntity.ok(dtoMapper.toPropertyWithOwnerDTO(property, owner));
        }

        User user = authService.getUserById(userId);
        boolean isAdmin = user != null && user.getRole().equalsIgnoreCase("admin");
        boolean isOwner = user != null && property.getOwnerId().equals(userId);

        if (isAdmin || isOwner) {
            return ResponseEntity.ok(dtoMapper.toPropertyWithOwnerDTO(property, owner));
        }

        if (!isPublic) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
        }

        return ResponseEntity.ok(dtoMapper.toPropertyWithOwnerDTO(property, owner));
    }

    @PostMapping
    public ResponseEntity<?> addProperty(
            @RequestHeader("X-User-Id") Long userId,
            @RequestBody PropertyDTO propertyDTO) {

        User user = authService.getUserById(userId);
        if (user == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("User not found");
        }

        String role = user.getRole().toLowerCase();
        if ((role.equals("seller") || role.equals("agent"))) {
            if (!user.isIdVerified() || !user.isApproved()) {
                return ResponseEntity.status(HttpStatus.FORBIDDEN)
                        .body("You must verify your identity and be approved by an admin before posting properties.");
            }
        }

        // 1. Create Property object from DTO
        models.Property property = new models.Property(
                null, // ID generated by manager
                propertyDTO.title(),
                propertyDTO.location(),
                propertyDTO.price(),
                propertyDTO.rooms(),
                propertyDTO.floor(),
                propertyDTO.description(),
                userId, // ownerId from header
                new java.util.ArrayList<>(), // photos
                new java.util.ArrayList<>(), // videos
                propertyDTO.distanceToMetro(),
                propertyDTO.distanceToUniversity());

        propertyManager.addProperty(property);
        return ResponseEntity.ok(dtoMapper.toPropertyDTO(property));
    }

    @PutMapping("/{id}")
    public ResponseEntity<?> updateProperty(
            @RequestHeader("X-User-Id") Long userId,
            @PathVariable Long id,
            @RequestBody PropertyDTO dto) {

        User user = authService.getUserById(userId);
        if (user == null)
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();

        Optional<Property> existingOpt = propertyManager.getPropertyById(id);
        if (existingOpt.isEmpty())
            return ResponseEntity.notFound().build();

        Property existing = existingOpt.get();
        // Check ownership
        if (!existing.getOwnerId().equals(userId) && !user.getRole().equalsIgnoreCase("admin")) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body("Not valid owner");
        }

        existing.setTitle(dto.title());
        existing.setLocation(dto.location());
        existing.setPrice(dto.price());
        existing.setRooms(dto.rooms());
        existing.setFloor(dto.floor());
        existing.setDescription(dto.description());
        // Update new fields
        existing.setDistanceToMetro(dto.distanceToMetro());
        existing.setDistanceToUniversity(dto.distanceToUniversity());

        if (dto.photos() != null)
            existing.setPhotos(dto.photos());
        if (dto.videos() != null)
            existing.setVideos(dto.videos());

        propertyManager.updateProperty(existing);
        return ResponseEntity.ok(dtoMapper.toPropertyDTO(existing));
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<?> deleteProperty(
            @RequestHeader("X-User-Id") Long userId,
            @PathVariable Long id) {

        User user = authService.getUserById(userId);
        if (user == null)
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();

        Optional<Property> existingOpt = propertyManager.getPropertyById(id);
        if (existingOpt.isEmpty())
            return ResponseEntity.notFound().build();

        Property existing = existingOpt.get();
        if (!existing.getOwnerId().equals(userId) && !user.getRole().equalsIgnoreCase("admin")) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body("Not valid owner");
        }

        propertyManager.deleteProperty(id);
        return ResponseEntity.ok("Property deleted");
    }

    @PostMapping("/{id}/verify")
    public ResponseEntity<?> verifyProperty(
            @RequestHeader("X-User-Id") Long userId,
            @PathVariable Long id) {

        User user = authService.getUserById(userId);
        if (user == null || (!user.getRole().equalsIgnoreCase("admin") && !user.getRole().equalsIgnoreCase("agent"))) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body("Only Admins or Agents can verify properties");
        }

        propertyManager.verifyProperty(id);
        return ResponseEntity.ok("Property verified");
    }

    @PostMapping("/{id}/archive")
    public ResponseEntity<?> archiveProperty(
            @RequestHeader("X-User-Id") Long userId,
            @PathVariable Long id) {

        User user = authService.getUserById(userId);
        Optional<Property> existingOpt = propertyManager.getPropertyById(id);
        if (existingOpt.isEmpty())
            return ResponseEntity.notFound().build();

        Property existing = existingOpt.get();
        if (!existing.getOwnerId().equals(userId) && !user.getRole().equalsIgnoreCase("admin")) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
        }

        propertyManager.archiveProperty(id);
        return ResponseEntity.ok("Archived");
    }

    @PostMapping("/{id}/photos")
    public ResponseEntity<?> addPhoto(
            @RequestHeader("X-User-Id") Long userId,
            @PathVariable Long id,
            @RequestParam("file") org.springframework.web.multipart.MultipartFile file) {

        User user = authService.getUserById(userId);
        Optional<Property> existingOpt = propertyManager.getPropertyById(id);
        if (existingOpt.isEmpty())
            return ResponseEntity.notFound().build();

        Property existing = existingOpt.get();
        if (!existing.getOwnerId().equals(userId)) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
        }

        try {
            // FileUploadService expects arrays, we wrap single file
            byte[][] filesData = new byte[][] { file.getBytes() };
            String[] fileNames = new String[] { file.getOriginalFilename() };
            List<String> paths = fileUploadService.savePropertyPhotos(id, filesData, fileNames);
            if (!paths.isEmpty()) {
                propertyManager.addPhotoToProperty(id, paths.get(0));
            }
            return ResponseEntity.ok("Photo added");
        } catch (java.io.IOException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error uploading");
        }
    }

    @DeleteMapping("/{id}/photos/{index}")
    public ResponseEntity<?> deletePhoto(
            @RequestHeader("X-User-Id") Long userId,
            @PathVariable Long id,
            @PathVariable int index) {

        User user = authService.getUserById(userId);
        Optional<Property> existingOpt = propertyManager.getPropertyById(id);
        if (existingOpt.isEmpty())
            return ResponseEntity.notFound().build();

        if (!existingOpt.get().getOwnerId().equals(userId)) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
        }

        propertyManager.removePhotoFromProperty(id, index);
        return ResponseEntity.ok("Photo deleted");
    }

    @PostMapping("/{id}/videos")
    public ResponseEntity<?> addVideo(
            @RequestHeader("X-User-Id") Long userId,
            @PathVariable Long id,
            @RequestParam("file") org.springframework.web.multipart.MultipartFile file) {

        User user = authService.getUserById(userId);
        Optional<Property> existingOpt = propertyManager.getPropertyById(id);
        if (existingOpt.isEmpty())
            return ResponseEntity.notFound().build();

        Property existing = existingOpt.get();
        if (!existing.getOwnerId().equals(userId)) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
        }

        try {
            // FileUploadService expects arrays
            byte[][] filesData = new byte[][] { file.getBytes() };
            String[] fileNames = new String[] { file.getOriginalFilename() };
            List<String> paths = fileUploadService.savePropertyVideos(id, filesData, fileNames);
            if (!paths.isEmpty()) {
                propertyManager.addVideoToProperty(id, paths.get(0));
            }
            return ResponseEntity.ok("Video added");
        } catch (java.io.IOException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error uploading video");
        }
    }

    @DeleteMapping("/{id}/videos/{index}")
    public ResponseEntity<?> deleteVideo(
            @RequestHeader("X-User-Id") Long userId,
            @PathVariable Long id,
            @PathVariable int index) {

        User user = authService.getUserById(userId);
        Optional<Property> existingOpt = propertyManager.getPropertyById(id);
        if (existingOpt.isEmpty())
            return ResponseEntity.notFound().build();

        if (!existingOpt.get().getOwnerId().equals(userId)) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
        }

        propertyManager.removeVideoFromProperty(id, index);
        return ResponseEntity.ok("Video deleted");
    }
}
