package services;

import models.Property;
import repositories.PropertyRepository;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

public class PropertyManager {
    private final PropertyRepository propertyRepository;

    public PropertyManager(PropertyRepository propertyRepository) {
        this.propertyRepository = propertyRepository;
    }

    public void addProperty(Property property) {
        // ID is auto-generated by DB
        propertyRepository.save(property);
    }

    public void editProperty(Long id, String title, String location, double price) {
        getPropertyById(id).ifPresent(p -> {
            p.setTitle(title);
            p.setLocation(location);
            p.setPrice(price);
            propertyRepository.save(p);
        });
    }

    public void updateProperty(Property property) {
        propertyRepository.save(property);
    }

    public void archiveProperty(Long id) {
        getPropertyById(id).ifPresent(p -> {
            p.setArchived(true);
            propertyRepository.save(p);
        });
    }

    public List<Property> getProperties() {
        return propertyRepository.findAll();
    }

    public Optional<Property> getPropertyById(Long id) {
        return propertyRepository.findById(id);
    }

    public void deleteProperty(Long id) {
        propertyRepository.deleteById(id);
    }

    public void verifyProperty(Long id) {
        getPropertyById(id).ifPresent(p -> {
            p.setVerified(true);
            propertyRepository.save(p);
        });
    }

    public List<Property> search(String keyword, Double minPrice, Double maxPrice, Integer rooms, Integer floor,
            Double minArea, Double maxArea, Double maxDistanceToMetro, Double maxDistanceToUniversity) {
        // Fetch all verified non-archived properties and filter in memory (or use
        // custom query)
        // For simplicity migrating existing logic:
        return propertyRepository.findByIsVerifiedTrue().stream()
                .filter(p -> !p.isArchived())
                .filter(p -> keyword == null || p.getTitle().toLowerCase().contains(keyword.toLowerCase())
                        || p.getLocation().toLowerCase().contains(keyword.toLowerCase()))
                .filter(p -> minPrice == null || p.getPrice() >= minPrice)
                .filter(p -> maxPrice == null || p.getPrice() <= maxPrice)
                .filter(p -> rooms == null || p.getRooms() == rooms)
                .filter(p -> floor == null || p.getFloor() == floor)
                .filter(p -> minArea == null || (p.getArea() != null && p.getArea() >= minArea))
                .filter(p -> maxArea == null || (p.getArea() != null && p.getArea() <= maxArea))
                .filter(p -> maxDistanceToMetro == null
                        || (p.getDistanceToMetro() != null && p.getDistanceToMetro() <= maxDistanceToMetro))
                .filter(p -> maxDistanceToUniversity == null || (p.getDistanceToUniversity() != null
                        && p.getDistanceToUniversity() <= maxDistanceToUniversity))
                .collect(Collectors.toList());
    }

    public List<Property> getMyProperties(Long ownerId) {
        return propertyRepository.findByOwnerId(ownerId);
    }

    public List<Property> getUnverifiedProperties() {
        return propertyRepository.findByIsVerifiedFalse();
    }

    // Photo management methods
    public void addPhotoToProperty(Long propertyId, String photoPath) {
        getPropertyById(propertyId).ifPresent(p -> {
            p.addPhoto(photoPath);
            propertyRepository.save(p);
        });
    }

    public void removePhotoFromProperty(Long propertyId, int photoIndex) {
        getPropertyById(propertyId).ifPresent(p -> {
            if (p.removePhoto(photoIndex)) {
                propertyRepository.save(p);
            }
        });
    }

    // Video management methods
    public void addVideoToProperty(Long propertyId, String videoPath) {
        getPropertyById(propertyId).ifPresent(p -> {
            p.addVideo(videoPath);
            propertyRepository.save(p);
        });
    }

    public void removeVideoFromProperty(Long propertyId, int videoIndex) {
        getPropertyById(propertyId).ifPresent(p -> {
            if (p.removeVideo(videoIndex)) {
                propertyRepository.save(p);
            }
        });
    }
}
